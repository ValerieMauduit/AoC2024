# Day 22: Monkey Market

# First star: The part about secrets is literal, the Historian explains. Each buyer produces a pseudorandom sequence of
# secret numbers where each secret is derived from the previous.
# In particular, each buyer's secret number evolves into the next secret number in the sequence via the following
# process:
# - Calculate the result of multiplying the secret number by 64. Then, mix this result into the secret number. Finally,
#   prune the secret number.
# - Calculate the result of dividing the secret number by 32. Round the result down to the nearest integer. Then, mix
#   this result into the secret number. Finally, prune the secret number.
# - Calculate the result of multiplying the secret number by 2048. Then, mix this result into the secret number.
#   Finally, prune the secret number.
# Each step of the above process involves mixing and pruning:
# - To mix a value into the secret number, calculate the bitwise XOR of the given value and the secret number. Then, the
#   secret number becomes the result of that operation.
# - To prune the secret number, calculate the value of the secret number modulo . Then, the secret number
#   becomes the result of that operation.
# After this process completes, the buyer is left with the next secret number in the sequence. The buyer can repeat this
# process as many times as necessary to produce more secret numbers.
# For each buyer, simulate the creation of 2000 new secret numbers. What is the sum of the 2000th secret number
# generated by each buyer?

# Second star: Of course, the secret numbers aren't the prices each buyer is offering! That would be ridiculous.
# Instead, the prices the buyer offers are just the ones digit of each of their secret numbers.
# Unfortunately, the monkey only knows how to decide when to sell by looking at the changes in price. Specifically, the
# monkey will only look for a specific sequence of four consecutive changes in price, then immediately sell when it sees
# that sequence.
# Worse, you can only give the monkey a single sequence of four price changes to look for. You can't change the sequence
# between buyers.
# You're going to need as many bananas as possible, so you'll need to determine which sequence of four price changes
# will cause the monkey to get you the most bananas overall.
# Figure out the best sequence to tell the monkey so that by looking for that same sequence of changes in every buyer's
# future prices, you get the most bananas in total. What is the most bananas you can get?


import os
import sys
current_dir = os.path.dirname(os.path.realpath(__file__))
parent_dir = os.path.dirname(current_dir)
sys.path.append(parent_dir)

from AoC_tools.read_data import read_data


def one_step(s):
    s1 = ((s * 64) ^ s) % 16777216
    s2 = (int(s1 / 32) ^ s1) % 16777216
    s3 = ((s2 * 2048) ^ s2) % 16777216
    return s3


def get_secret(secret, steps=2000):
    for _ in range(steps):
        secret = one_step(secret)
    return secret


def get_summary(secrets, steps=2000):
    return sum([get_secret(secret, steps) for secret in secrets])


def get_sequence(secret, steps=2000):
    sequence = [int(str(secret)[-1])]
    for _ in range(steps):
        secret = one_step(secret)
        sequence += [int(str(secret)[-1])]
    return sequence


def get_codes(sequence):
    diff = [sequence[i] - sequence[i - 1] for i in range(1, len(sequence))]
    bananas = {}
    for i in range(4, len(sequence)):
        code = ''.join([str(x) for x in diff[(i - 4):i]])
        if code not in bananas.keys():
            bananas[code] = sequence[i]
    return bananas


def find_best_deal(secrets, steps=2000):
    bananas = [get_codes(get_sequence(secret, steps)) for secret in secrets]
    print('bananas done for all monkeys')
    deals = bananas[0]
    for i in range(1, len(bananas)):
        if i % 100 == 0:
            print(f'Monkey {i}')
        for k, v in bananas[i].items():
            if k in deals.keys():
                deals[k] += v
            else:
                deals[k] = v
    return max(deals.values())


def run(data_dir, star):
    data = read_data(f'{data_dir}/input-day22.txt', numbers=True)

    if star == 1:  # The final answer is: 19854248602
        solution = get_summary(data)
    elif star == 2:  # The final answer is: 2223 but my test 2 does not pass!
        solution = find_best_deal(data)
    else:
        raise Exception('Star number must be either 1 or 2.')

    print(f'The solution (star {star}) is: {solution}')
    return solution
